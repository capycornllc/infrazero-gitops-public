# PRD: Public GitOps Base for IaC Autodeploy (k3s + Argo CD)

## Summary
Create a public, reusable GitOps base that powers an IaC autodeploy tool. The base repo is cloned into a private GitOps repo by the infra pipeline and customized with overlays/patches. It must deploy containerized web apps to k3s via Argo CD, including ingress, cert-manager, and external secrets integration. App definitions come from a generated config derived from the `deployed_apps` input, and all secrets are sourced from an externally hosted Infisical instance via CSI (no in-cluster secret manager).

## Background and context
We have a UI, an infra repo, and this public GitOps base repo. The UI sends customer inputs to the infra repo on GitHub, and a GitHub Actions pipeline provisions servers and generates the private GitOps repo by cloning this public base and applying overlays/patches. The pipeline also passes a `deployed_apps` payload (JSON) that lists container images, FQDNs, replica counts, and resource limits. Secrets are managed by a self-hosted Infisical instance outside the cluster and injected via CSI. The public base must remain generic and safe to publish while enabling the infra repo to specialize it per customer.

## Goals
- Provide a public GitOps base for k3s + Argo CD that is generic and reusable.
- Keep all app workloads in one Kubernetes namespace and one Argo CD Application.
- Provide a single generated config (from `deployed_apps`) as the source of truth for:
  - Workload definitions, images, and tags
  - Replica counts, resource limits, and probes
  - Domain names and TLS/Let's Encrypt settings
  - Secret mounts using CSI
- Support external secret management via an out-of-cluster Infisical instance.
- Keep platform add-ons (ingress-nginx, cert-manager, secrets-store CSI + Infisical provider) pinned and GitOps-managed.
- Expose clear overlay/patch points for the infra repo to customize per customer.

## Non-goals
- Running a self-hosted secret manager inside the cluster.
- Multi-namespace app layouts in the template.
- Multi-cluster or multi-tenant orchestration.
- Provisioning servers or cloud infrastructure (owned by the infra repo).
- Shipping opinionated monitoring or logging stacks (can be added later).

## Users and personas
- Platform operator: bootstraps clusters, configures ingress/TLS, manages Argo CD.
- Application developer: defines services and images through the UI (not directly in GitOps).
- Infra automation pipeline: generates overlays/patches and app config from `deployed_apps`.

## Scope and requirements

### Repository structure (template)
- apps/root/application.yaml: Argo CD app-of-apps bootstrap.
- clusters/<env>/kustomization.yaml: environment roots (dev/test/prod).
- projects/<env>/project.yaml: Argo CD projects and repo allowlist.
- platform/: cluster add-ons (ingress-nginx, cert-manager, secrets-store CSI, optional sealed-secrets, namespaces, network policies).
- applications/app/: single Argo CD Application for the entire web app.
- config/app-config.yaml: generated source of truth for app workloads and routing.
- charts/app/: custom Helm chart (preferred) or a Kustomize-based renderer that consumes config/app-config.yaml.
- overlays/: clear, documented patch points for the infra repo to inject customer-specific config.
- docs/: quickstart and operations guides.

### Main config file (single source of truth)
The base repo must include a single YAML config file with a clear, versioned schema. It is generated by the infra repo from `deployed_apps` and should support:
- Global settings:
  - app name and namespace
  - base domain, TLS enabled flag, and default ClusterIssuer
  - external secret manager URL and auth mode (Infisical via CSI)
  - default resource presets (optional)
- Workloads list (multiple services in one namespace):
  - type: Deployment or CronJob (optionally Job)
  - image repository and tag
  - replica count (for Deployments)
  - container ports and service ports
  - health probes (readiness/liveness)
  - resource requests/limits
  - environment variables (plain and from CSI)
  - volume mounts (including CSI secret volume)
  - ingress rules per workload (hostnames, paths, TLS secret name)
- Image update fields designed for CI to edit (for example services[].image.tag) when the infra pipeline needs to roll images.
- Optional toggles for:
  - creating Services and Ingresses
  - enabling TLS (Let's Encrypt prod/staging)
  - network policies

### App rendering and delivery
- Prefer a custom Helm chart in-repo that renders all workloads from the single config file.
- Argo CD should deploy the app via a single Application resource pointing to the chart and values file.
- All resources should be labeled consistently and confined to the configured namespace.
- The repo should ship a JSON Schema (or similar) for config/app-config.yaml and a validation script.

### Platform components (k3s-compatible)
- ingress-nginx: NodePort configuration suitable for k3s without CCM.
- cert-manager: ClusterIssuers for Let's Encrypt staging and production.
- secrets-store CSI driver + Infisical provider configured without in-cluster secret manager.
- optional sealed-secrets for small bootstrap secrets (disabled by default in the template).
- namespaces and baseline network policies (default deny with ingress-nginx exceptions).

### CI/CD integration
- Infra repo pipeline generates config/app-config.yaml and overlays from `deployed_apps`.
- Renovate (or similar) updates pinned chart versions for platform add-ons.
- A lightweight validation step verifies config schema and kustomize/helm render.

### Documentation
- Quickstart: clone template, apply root app, then use infra overlays to specialize.
- Operations: Argo CD access, ingress/TLS setup, and image update flow.
- Secrets: how to connect to external Infisical and define secret mounts.
- Infra integration: how overlays map `deployed_apps` inputs to app workloads.

## User journeys
1) New project bootstrap
- User submits app inputs in UI.
- Infra repo pipeline provisions servers and generates private GitOps repo from this base.
- Pipeline injects overlays and generated config/app-config.yaml.
- Apply apps/root/application.yaml in the cluster.
- Argo CD syncs platform and app.

2) Add a new service
- User adds service in UI (produces a new `deployed_apps` payload).
- Infra repo regenerates overlays/config.
- Argo CD renders and deploys the new Deployment/Service/Ingress.

3) Update image tags
- Infra pipeline updates services[].image.tag in config/app-config.yaml.
- Argo CD syncs and rolls out updated images.

## Success metrics
- Time from UI submission to first successful deploy <= 30 minutes on a fresh k3s cluster.
- All app changes captured by a single config file and rendered by Argo CD.
- Zero secrets stored in the repo.

## Risks and mitigations
- External secret manager dependency: document outage behavior and use CSI retries.
- Single namespace blast radius: enforce labels, network policies, and resource quotas.
- Ingress/TLS complexity: ship clear defaults and staging/prod issuer toggles.
 - Infra-to-GitOps handoff: document overlays and validate generated config.

## Epics and stories

### Epic 1: Public GitOps base and bootstrap
Stories:
- As an operator, I can apply a root Argo CD Application that bootstraps the cluster.
- As an operator, I can target different environments using clusters/<env> overlays.
- As an operator, I can control allowed source repos via an Argo CD Project.
- As an automation pipeline, I can clone this public repo and apply overlays safely.

### Epic 2: App config derived from deployed_apps
Stories:
- As an automation pipeline, I can generate config/app-config.yaml from `deployed_apps`.
- As an operator, I can validate the config file with a schema and fail fast on errors.
- As a developer, I can define Ingress rules and TLS per workload via UI inputs.
- As a developer, I can set replicas, resources, probes, and ports per workload via UI inputs.
- As a developer, I can mount external secrets via CSI by configuring the workload.

### Epic 3: Platform add-ons for k3s
Stories:
- As an operator, I can install ingress-nginx with NodePort defaults for k3s.
- As an operator, I can install cert-manager with staging and prod ClusterIssuers.
- As an operator, I can install secrets-store CSI and the Infisical provider without in-cluster secret manager.
- As an operator, I can enable baseline network policies and namespaces via GitOps.

### Epic 4: TLS and domain management
Stories:
- As an operator, I can set base domains and per-service hosts in one config file.
- As an operator, I can switch between Let's Encrypt staging and prod issuers per environment.
- As an operator, I can disable TLS for internal-only services.

### Epic 5: Infra-driven image updates
Stories:
- As the infra pipeline, I can update image tags in config/app-config.yaml and commit overlays.
- As an operator, I can auto-sync Argo CD to roll out the new images safely.
- As an operator, I can audit image tag changes via Git history.

### Epic 6: Documentation and onboarding
Stories:
- As a new operator, I can follow a quickstart to deploy the base on k3s.
- As an operator, I can find clear instructions for Argo CD access and troubleshooting.
- As an automation engineer, I can follow overlay guidance that maps `deployed_apps` to workloads.
- As a developer, I can understand how to add services and secrets from docs.

## Open questions
- Should the app renderer be Helm-first (preferred) or a Kustomize generator with committed output?
- Do we need optional HPA configuration in the main config file from day one?
- Should the template include resource quotas/limit ranges by default?
- Should `deployed_apps` support per-app env vars and secret references in v1?

